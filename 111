

# æŸ¥çœ‹çŠ¶æ€
sudo systemctl status paxg-monitor.service --no-pager

# æŸ¥çœ‹æœ€æ–°æ—¥å¿—
sudo journalctl -u paxg-monitor.service -n 20 --no-pager

# å®æ—¶æŸ¥çœ‹æ—¥å¿—
sudo journalctl -u paxg-monitor.service -f

# é‡å¯æœåŠ¡
sudo systemctl restart paxg-monitor.service








# åœ¨ PowerShell ä¸­ç™»å½•
ssh root@165.232.160.78

# åœæ­¢å½“å‰æœåŠ¡
sudo systemctl stop paxg-monitor.service


é•¿ä»£ç   



sudo cat > /home/paxgmonitor/paxg-monitor/.env << 'EOF'
BOT_TOKEN=8349710919:AAHqNaREjy87vl43CbLx5CLHPnnsYNVonFE
CHAT_ID=-5173315739
CHECK_SEC=10
CRAWLBASE_TOKEN=bxOnCeK-j6WiGKWDMvCH9Q
EOF

# è®¾ç½®æ–‡ä»¶æƒé™
sudo chown paxgmonitor:paxgmonitor /home/paxgmonitor/paxg-monitor/.env
sudo chmod 600 /home/paxgmonitor/paxg-monitor/.env





åˆ›å»ºæ•°æ®ç›®å½•

sudo mkdir -p /home/paxgmonitor/paxg-monitor/data
sudo chown -R paxgmonitor:paxgmonitor /home/paxgmonitor/paxg-monitor
sudo chmod -R 755 /home/paxgmonitor/paxg-monitor



åˆ›å»º Systemd æœåŠ¡æ–‡ä»¶

sudo cat > /etc/systemd/system/paxg-monitor.service << 'EOF'
[Unit]
Description=PAXG Spread Monitor
After=network.target

[Service]
Type=simple
User=paxgmonitor
WorkingDirectory=/home/paxgmonitor/paxg-monitor
Environment="PATH=/home/paxgmonitor/paxg-monitor/venv/bin"
ExecStart=/home/paxgmonitor/paxg-monitor/venv/bin/python /home/paxgmonitor/paxg-monitor/main.py
Restart=always
RestartSec=30
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
EOF


sudo systemctl daemon-reload




# å¯åŠ¨æœåŠ¡
sudo systemctl start paxg-monitor.service

# æŸ¥çœ‹çŠ¶æ€
sudo systemctl status paxg-monitor.service --no-pager

# æŸ¥çœ‹æ—¥å¿—ï¼ˆè§‚å¯Ÿ3-5åˆ†é’Ÿï¼‰
sudo journalctl -u paxg-monitor.service -f



sudo cat > /home/paxgmonitor/paxg-monitor/main.py << 'EOF'
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys
import time
import json
import logging
import datetime as dt
import pickle
from datetime import datetime
from telegram import Bot
from typing import Dict, Optional
from dataclasses import dataclass, field
import requests
from urllib.parse import quote

# åŠ è½½ .env æ–‡ä»¶
from dotenv import load_dotenv
load_dotenv()

# ===== æ™ºèƒ½é…ç½®å¸¸é‡ =====
CONFIG = {
    # æ£€æŸ¥é—´éš”ï¼ˆç§’ï¼‰
    "BASE_CHECK_SEC": 30,     # é¢„è­¦åŒºé—´ï¼š30ç§’
    "SAFE_CHECK_SEC": 120,    # å®‰å…¨åŒºé—´ï¼š2åˆ†é’Ÿï¼ˆ120ç§’ï¼‰
    "DANGER_CHECK_SEC": 10,   # å±é™©åŒºé—´ï¼š10ç§’
    
    # APIé…ç½®
    "BASE_URL": "https://omni-client-api.prod.ap-northeast-1.variational.io/metadata/stats",
    "HIGH_THRESHOLD": 16.0,
    "LOW_THRESHOLD": 10.0,
    
    # åŒºé—´å®šä¹‰
    "DANGER_LOW_MAX": 8.0,
    "WARNING_LOW_MAX": 10.0,
    "SAFE_MIN": 11.0,
    "SAFE_MAX": 15.0,
    "WARNING_HIGH_MIN": 16.0,
    "DANGER_HIGH_MIN": 18.0,
    
    "DURATION_SEC": 1.0,
    "GEAR_STEP": 0.5,
    "CACHE_TTL": 30.0,
    
    # â† ä¿®æ”¹ï¼š2å°æ—¶æ¡£ä½è®°å¿†é‡ç½®ï¼ˆ7200ç§’ï¼‰
    "GEAR_RESET_TIMEOUT": 7200,  # 2å°æ—¶ = 7200ç§’
    
    # APIè¶…æ—¶å’Œé‡è¯•é…ç½®
    "API_TIMEOUT": 20,
    "ERROR_BACKOFF": 60,
    "MAX_ERROR_STREAK": 3,
}

# ===== æ—¥å¿—é…ç½® =====
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler("/var/log/paxg-monitor/monitor.log", encoding='utf-8')
    ]
)
logger = logging.getLogger(__name__)


@dataclass
class SpreadState:
    timers: Dict[float, float] = field(default_factory=dict)
    peak: float = 0.0
    last_gear: Optional[float] = None
    last_alarm_time: float = 0.0  # ä¸Šæ¬¡æŠ¥è­¦æ—¶é—´æˆ³
    
    def clear_timers(self):
        self.timers.clear()


@dataclass
class PriceData:
    paxg: Optional[Dict] = None
    xaut: Optional[Dict] = None
    last_update: float = 0.0
    
    def is_expired(self, ttl: float) -> bool:
        return time.time() - self.last_update > ttl


class PersistState:
    """çŠ¶æ€æŒä¹…åŒ–ç±»"""
    FILE_PATH = "/home/paxgmonitor/paxg-monitor/data/spread_state.pkl"
    
    @classmethod
    def load(cls) -> tuple:
        if os.path.exists(cls.FILE_PATH):
            try:
                with open(cls.FILE_PATH, 'rb') as f:
                    data = pickle.load(f)
                    logger.info(f"âœ… çŠ¶æ€åŠ è½½æˆåŠŸ: {data}")
                    return (data.get('high'), data.get('low'), 
                            data.get('high_time', 0), data.get('low_time', 0))
            except Exception as e:
                logger.warning(f"âŒ çŠ¶æ€åŠ è½½å¤±è´¥: {e}")
        logger.info("âš ï¸ æ— å†å²çŠ¶æ€æ–‡ä»¶")
        return None, None, 0, 0
    
    @classmethod
    def save(cls, high_gear: Optional[float], low_gear: Optional[float], 
             high_time: float = 0, low_time: float = 0) -> None:
        try:
            with open(cls.FILE_PATH, 'wb') as f:
                pickle.dump({
                    'high': high_gear, 
                    'low': low_gear,
                    'high_time': high_time,
                    'low_time': low_time
                }, f)
                logger.info(f"âœ… çŠ¶æ€ä¿å­˜æˆåŠŸ: high={high_gear}({high_time}), low={low_gear}({low_time})")
        except Exception as e:
            logger.error(f"âŒ çŠ¶æ€ä¿å­˜å¤±è´¥: {e}")


class SpreadMonitor:
    def __init__(self, bot_token: str, chat_id: str):
        logger.info("=" * 80)
        logger.info("ğŸ”§ åˆå§‹åŒ– SpreadMonitor")
        logger.info("=" * 80)
        
        if ":" not in bot_token:
            raise ValueError("Bot Token æ ¼å¼é”™è¯¯: å¿…é¡»åŒ…å« ':'")
        
        self.bot = Bot(token=bot_token)
        self.chat_id = chat_id
        self.cache = PriceData()
        self.high_state = SpreadState(peak=CONFIG["HIGH_THRESHOLD"])
        self.low_state = SpreadState(peak=CONFIG["LOW_THRESHOLD"])
        self.crawlbase_token = os.getenv("CRAWLBASE_TOKEN")
        self.error_streak = 0
        
        if not self.crawlbase_token:
            logger.warning("âš ï¸ æœªè®¾ç½® CRAWLBASE_TOKENï¼Œå°†ç›´æ¥è¯·æ±‚APIï¼ˆå¯èƒ½è¢«é˜»æ­¢ï¼‰")
        
        self._load_persistent_state()
    
    def _load_persistent_state(self):
        """åŠ è½½æŒä¹…åŒ–çš„æ¡£ä½è®°å¿†å’Œæ—¶é—´æˆ³"""
        high_gear, low_gear, high_time, low_time = PersistState.load()
        self.high_state.last_gear = high_gear
        self.low_state.last_gear = low_gear
        self.high_state.last_alarm_time = high_time
        self.low_state.last_alarm_time = low_time
        
        # æ ¼å¼åŒ–æ—¶é—´æ˜¾ç¤º
        high_time_str = datetime.fromtimestamp(high_time).strftime('%m-%d %H:%M') if high_time else "æ— "
        low_time_str = datetime.fromtimestamp(low_time).strftime('%m-%d %H:%M') if low_time else "æ— "
        logger.info(f"ğŸ“Š æ¡£ä½çŠ¶æ€: é«˜ä»·æ¡£={self.high_state.last_gear}({high_time_str}), ä½ä»·æ¡£={self.low_state.last_gear}({low_time_str})")
    
    def get_check_interval(self, current_spread: float) -> int:
        """æ™ºèƒ½è°ƒæ•´æ£€æŸ¥é—´éš”"""
        if current_spread <= CONFIG["DANGER_LOW_MAX"]:
            return CONFIG["DANGER_CHECK_SEC"]
        elif current_spread <= CONFIG["WARNING_LOW_MAX"]:
            return CONFIG["BASE_CHECK_SEC"]
        elif CONFIG["SAFE_MIN"] < current_spread < CONFIG["SAFE_MAX"]:
            return CONFIG["SAFE_CHECK_SEC"]
        elif current_spread < CONFIG["DANGER_HIGH_MIN"]:
            return CONFIG["BASE_CHECK_SEC"]
        else:
            return CONFIG["DANGER_CHECK_SEC"]
    
    def get_both_assets(self) -> bool:
        """ä½¿ç”¨ Crawlbase API è·å–ä»·æ ¼æ•°æ®"""
        if not self.cache.is_expired(CONFIG["CACHE_TTL"]):
            logger.debug("âœ… ä½¿ç”¨ç¼“å­˜æ•°æ®")
            return True
        
        start_time = time.time()
        
        try:
            logger.debug("ğŸŒ è¯·æ±‚API...")
            
            if self.crawlbase_token:
                logger.debug("ä½¿ç”¨ Crawlbase API...")
                encoded_url = quote(CONFIG['BASE_URL'], safe='')
                crawlbase_url = f"https://api.crawlbase.com/?token={self.crawlbase_token}&url={encoded_url}"
                
                headers = {
                    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                    "Accept": "application/json"
                }
                resp = requests.get(crawlbase_url, headers=headers, timeout=CONFIG["API_TIMEOUT"])
                elapsed = time.time() - start_time
                logger.debug(f"âœ… Crawlbase æˆåŠŸ: çŠ¶æ€ç ={resp.status_code}, è€—æ—¶={elapsed:.2f}ç§’")
            else:
                logger.debug("ç›´æ¥è¯·æ±‚APIï¼ˆå¯èƒ½è¢«é˜»æ­¢ï¼‰...")
                headers = {
                    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                    "Accept": "application/json"
                }
                resp = requests.get(CONFIG['BASE_URL'], headers=headers, timeout=CONFIG["API_TIMEOUT"]-5)
                elapsed = time.time() - start_time
                logger.debug(f"âœ… ç›´æ¥è¯·æ±‚æˆåŠŸ: çŠ¶æ€ç ={resp.status_code}, è€—æ—¶={elapsed:.2f}ç§’")
            
            resp.raise_for_status()
            data = resp.json()
            
            listings = {item["ticker"]: item for item in data["listings"]}
            if "PAXG" not in listings or "XAUT" not in listings:
                logger.error("âŒ ç¼ºå°‘äº¤æ˜“å¯¹")
                self.error_streak += 1
                return False
            
            self.cache.paxg = self._parse_asset(listings["PAXG"])
            self.cache.xaut = self._parse_asset(listings["XAUT"])
            self.cache.last_update = time.time()
            self.error_streak = 0
            logger.debug("âœ… æ•°æ®æ›´æ–°æˆåŠŸ")
            return True
            
        except requests.exceptions.Timeout:
            elapsed = time.time() - start_time
            self.error_streak += 1
            logger.error(f"âŒ APIè¶…æ—¶: {elapsed:.2f}ç§’åè¶…æ—¶ (è¿ç»­é”™è¯¯{self.error_streak}æ¬¡)")
            return False
            
        except requests.exceptions.HTTPError as e:
            self.error_streak += 1
            logger.error(f"âŒ HTTPé”™è¯¯: {e} (è¿ç»­é”™è¯¯{self.error_streak}æ¬¡)")
            return False
            
        except Exception as e:
            self.error_streak += 1
            logger.error(f"âŒ APIå¤±è´¥: {e} (è¿ç»­é”™è¯¯{self.error_streak}æ¬¡)")
            return False
    
    @staticmethod
    def _parse_asset(item: dict) -> dict:
        return {
            "mark": float(item["mark_price"]),
            "bid_1k": float(item["quotes"]["size_1k"]["bid"]),
            "ask_1k": float(item["quotes"]["size_1k"]["ask"]),
        }
    
    def calculate_spreads(self) -> Optional[dict]:
        if not self.cache.paxg or not self.cache.xaut:
            return None
        paxg, xaut = self.cache.paxg, self.cache.xaut
        return {
            "mark": paxg["mark"] - xaut["mark"],
            "short": paxg["bid_1k"] - xaut["ask_1k"],
            "long": paxg["ask_1k"] - xaut["bid_1k"],
        }
    
    @staticmethod
    def calculate_gear(value: float) -> float:
        return int(value * 2) / 2
    
    def check_threshold(
        self, 
        spreads: dict,
        state: SpreadState,
        opposite_state: SpreadState,
        threshold: float,
        is_high: bool
    ) -> bool:
        mark_spread = spreads["mark"]
        directional_spread = spreads["short" if is_high else "long"]
        
        condition = mark_spread >= threshold if is_high else mark_spread <= threshold
        
        if not condition:
            if state.timers:
                state.clear_timers()
                logger.info(f"  æ¸…é™¤{'é«˜ä»·â‰¥16' if is_high else 'ä½ä»·â‰¤10'}è®¡æ—¶å™¨")
            return False
        
        current_gear = self.calculate_gear(mark_spread)
        
        # æ£€æŸ¥æ¡£ä½è®°å¿†æ˜¯å¦å·²è¶…æ—¶ï¼ˆ2å°æ—¶ï¼‰
        if state.last_gear is not None:
            time_since_last_alarm = time.time() - state.last_alarm_time
            if time_since_last_alarm > CONFIG["GEAR_RESET_TIMEOUT"]:
                logger.info(f"  â° {'é«˜ä»·' if is_high else 'ä½ä»·'}æ¡£ä½è®°å¿†å·²è¶…æ—¶({time_since_last_alarm/3600:.1f}å°æ—¶ > {CONFIG['GEAR_RESET_TIMEOUT']/3600}å°æ—¶)ï¼Œæ¸…é™¤æ¡£ä½è®°å¿†")
                state.last_gear = None
                state.last_alarm_time = 0
        
        # æ¡£ä½é€’è¿›æ£€æŸ¥
        if is_high:
            step_check = current_gear >= (state.last_gear or -999) + CONFIG["GEAR_STEP"]
        else:
            step_check = current_gear <= (state.last_gear or 999) - CONFIG["GEAR_STEP"]
        
        if not step_check:
            return False
        
        if current_gear not in state.timers:
            state.timers[current_gear] = time.time()
            logger.info(f"  æ¡£ä½ {current_gear:.1f} å¼€å§‹è®¡æ—¶")
        
        if time.time() - state.timers[current_gear] >= CONFIG["DURATION_SEC"]:
            state.peak = mark_spread
            state.last_gear = current_gear
            state.last_alarm_time = time.time()  # è®°å½•æŠ¥è­¦æ—¶é—´æˆ³
            opposite_state.last_gear = None      # æ¸…é™¤ç›¸åæ–¹å‘æ¡£ä½
            opposite_state.last_alarm_time = 0   # æ¸…é™¤ç›¸åæ–¹å‘æ—¶é—´æˆ³
            
            self._save_persistent_state()
            
            action = "åšç©ºPAXG@å¸‚ä»·ï¼Œåšå¤šXAUT@å¸‚ä»·" if is_high else "åšå¤šPAXG@å¸‚ä»·ï¼Œåšç©ºXAUT@å¸‚ä»·"
            msg = (
                f"ğŸ”” PAXG {'é«˜ä»·â‰¥16' if is_high else 'ä½ä»·â‰¤10'}æº¢ä»·ï¼\n"
                f"çœŸå®æˆäº¤ä»·å·®: {directional_spread:.2f}\n"
                f"ï¼ˆ{action}ï¼‰\n"
                f"Markå‚è€ƒ: {mark_spread:.2f}"
            )
            
            self.send_message(msg)
            logger.info(f"  âœ… {'é«˜ä»·' if is_high else 'ä½ä»·'}æŠ¥è­¦å‘é€: æ¡£ä½ {current_gear:.1f}")
            state.clear_timers()
            return True
        
        return False
    
    def _save_persistent_state(self):
        """ä¿å­˜æ¡£ä½çŠ¶æ€å’Œæ—¶é—´æˆ³åˆ°æ–‡ä»¶"""
        PersistState.save(
            self.high_state.last_gear, 
            self.low_state.last_gear,
            self.high_state.last_alarm_time,
            self.low_state.last_alarm_time
        )
    
    def send_message(self, msg: str) -> None:
        """å‘é€Telegramæ¶ˆæ¯"""
        try:
            clean_msg = msg.replace('\n', ' ')
            logger.info(f"ğŸ“¤ å‘é€æ¶ˆæ¯: {clean_msg}")
            
            result = self.bot.send_message(chat_id=self.chat_id, text=msg)
            logger.info(f"âœ… æ¶ˆæ¯æˆåŠŸ: {result.message_id}")
            time.sleep(2)
        except Exception as e:
            logger.error(f"âŒ å‘é€å¤±è´¥: {e}")
    
    def run_continuous(self):
        """24/7 æ™ºèƒ½ç›‘æ§ - ç²¾ç¡®æ—¶é—´æ§åˆ¶ç‰ˆ"""
        logger.info("=" * 80)
        logger.info("ğŸš€ 24/7 æ™ºèƒ½ç›‘æ§æ¨¡å¼å¯åŠ¨ï¼ˆåŠ¨æ€è°ƒæ•´é¢‘ç‡ + åŒå‘2å°æ—¶æ¡£ä½è®°å¿†ï¼‰")
        logger.info("æŒ‰ Ctrl+C åœæ­¢")
        logger.info("=" * 80)
        
        check_count = 0
        error_count = 0
        last_spread = 0.0
        
        while True:
            loop_start = time.time()
            
            try:
                # è·å–ä»·å·®
                spreads = None
                if self.get_both_assets():
                    error_count = 0
                    self.error_streak = 0
                    spreads = self.calculate_spreads()
                
                if spreads:
                    current_spread = spreads["mark"]
                    check_count += 1
                    
                    # æ¯10æ¬¡æ£€æŸ¥æˆ–ä»·å·®å˜åŒ–è¾ƒå¤§æ—¶æ‰“å°æ—¥å¿—
                    if check_count % 10 == 0 or abs(current_spread - last_spread) > 0.1:
                        gear = self.calculate_gear(current_spread)
                        logger.info(f"ğŸ¯ æ£€æŸ¥ #{check_count}: Mark={current_spread:.2f} æ¡£ä½={gear:.1f}")
                        last_spread = current_spread
                    
                    # æ£€æŸ¥é˜ˆå€¼ï¼ˆé«˜ä»·å’Œä½ä»·éƒ½ä¼šè‡ªåŠ¨æ£€æŸ¥2å°æ—¶è¶…æ—¶ï¼‰
                    self.check_threshold(spreads, self.high_state, self.low_state, CONFIG["HIGH_THRESHOLD"], True)
                    self.check_threshold(spreads, self.low_state, self.high_state, CONFIG["LOW_THRESHOLD"], False)
                else:
                    error_count += 1
                    if error_count >= 5:
                        logger.warning(f"âš ï¸ è¿ç»­ {error_count}æ¬¡è·å–æ•°æ®å¤±è´¥")
            
            except Exception as e:
                logger.exception(f"âŒ ç›‘æ§å¾ªç¯é”™è¯¯: {e}")
            
            # ç²¾ç¡®æ—¶é—´æ§åˆ¶
            loop_duration = time.time() - loop_start
            
            # æ ¹æ®å½“å‰ä»·å·®åŠ¨æ€è°ƒæ•´ä¼‘çœ æ—¶é—´
            if spreads:
                target_interval = self.get_check_interval(spreads["mark"])
            else:
                # è¿ç»­é”™è¯¯æ—¶ä½¿ç”¨é€€é¿ç­–ç•¥
                if self.error_streak >= CONFIG["MAX_ERROR_STREAK"]:
                    target_interval = CONFIG["ERROR_BACKOFF"]
                    logger.warning(f"âš ï¸ è¿ç»­é”™è¯¯{self.error_streak}æ¬¡ï¼Œä½¿ç”¨é€€é¿é—´éš”{target_interval}ç§’")
                else:
                    target_interval = CONFIG["BASE_CHECK_SEC"]
            
            sleep_time = target_interval - loop_duration
            
            if sleep_time > 0:
                logger.debug(f"â° ç›®æ ‡é—´éš”={target_interval}ç§’, å¾ªç¯è€—æ—¶={loop_duration:.2f}ç§’, å®é™…ä¼‘çœ ={sleep_time:.2f}ç§’")
                time.sleep(sleep_time)
            else:
                logger.warning(f"âš ï¸ å¾ªç¯è€—æ—¶{loop_duration:.2f}ç§’è¶…è¿‡ç›®æ ‡é—´éš”{target_interval}ç§’ï¼Œç«‹å³è¿›å…¥ä¸‹æ¬¡å¾ªç¯")
    
    def run(self):
        self.run_continuous()


def validate_config() -> bool:
    logger.info("éªŒè¯é…ç½®...")
    required = ["BOT_TOKEN", "CHAT_ID"]
    for var in required:
        value = os.getenv(var)
        if not value:
            logger.error(f"ç¼ºå°‘ {var}")
            return False
        logger.info(f"{var}: {value[:10]}...")
    
    token = os.getenv("BOT_TOKEN")
    if ":" not in token:
        logger.error("BOT_TOKENæ ¼å¼é”™è¯¯")
        return False
    
    logger.info("âœ… é…ç½®éªŒè¯é€šè¿‡")
    return True


if __name__ == "__main__":
    if not validate_config():
        logger.error("âŒ é…ç½®éªŒè¯å¤±è´¥ï¼Œé€€å‡º")
        exit(1)
    
    logger.info("ğŸ¯ è¿è¡Œæ¨¡å¼: 24/7 æ™ºèƒ½ç›‘æ§ï¼ˆåŠ¨æ€è°ƒæ•´é¢‘ç‡ + åŒå‘2å°æ—¶æ¡£ä½è®°å¿†ï¼‰")
    
    monitor = SpreadMonitor(
        bot_token=os.getenv("BOT_TOKEN"),
        chat_id=os.getenv("CHAT_ID")
    )
    
    try:
        monitor.run()
    except KeyboardInterrupt:
        logger.info("âœ… ç”¨æˆ·æ‰‹åŠ¨åœæ­¢ç›‘æ§")
    except Exception as e:
        logger.exception(f"âŒ è‡´å‘½é”™è¯¯: {e}")
        exit(1)
EOF




